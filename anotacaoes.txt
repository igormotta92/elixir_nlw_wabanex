# Código Aula
  # together (Aula 1)
  # unidade (Aula 2)
  # embuscadeevolução (Aula 3)

--------------------------------------------------------------------------------
### Aula 01 ###

##Inicializando o Projeto
  $ mix phx.new wabanex --no-html --no-webpack

##Criando banco de dados
  $ mix ecto.setup

##Abrindo IEX interativo
  -- iex -> Elixir Interativo
  -- -S mix -> Abrindo IEX dentro do próprio projeto
  $ iex -S mix || $ iex.bat -S mix

|> Pattern Match (É o casamento dos padrões)
  No Elixir o =(é um operador de match)

  [1,x,2] = [1,2,3]
  |> x agora é 2

  {:ok, x} = File.read("students.csv")
  |> {:ok, "\"banana\""}
  |> x agora é o conteúdo do arquivo, "\"banana\""

  {:error, x} = File.read("students22.csv")
  |> {:error, :enoent}
  |> x agora é o :enoent

|> Chamando um modulo pelo iex
  <nome_modulo><funcao>
  Wabanex.IMC.calculate("students.csv")

#Subindo servidor phoenix
  $ mix phx.server
  http://localhost:4000/dashboard

###Fluxo de requisições 
  A porta de entrada é pelas rotas.
  \wabanex_web\router.ex

### Extras
Solid com Elixir
https://www.youtube.com/watch?v=rmftOs2BzgU

Livro de Elixir: Elixir in action

#Recursão
Tail Call Pptimization

--------------------------------------------------------------------------------
### Aula 02 ###

## Criando migration
  $ mix ecto.gen.migration create_users_table

## Executar migration
  $ mix ecto.migrate

## Resetar banco de dados (drop o banco e executa todas migrations)
  $ mix ecto.reset

### Schema é quase igual a um modelo
### Uma struct de certo modo é um map com nome %nome{}

## Interação com o banco de dados
  Toda interação com banco de dados é feita utilizando modulo [Wabanex.Repo]
  Quando há execução de query é retornado um debug com informações da query
  Validações podem ser em memória (validate_length, validate_format) ou execuções no banco (unique_constraint)

  # Modulo schema (lib\wabanex\user.ex) que recebe os parâmetros e o lib\wabanex\repo.ex que executa as ações no banco

--------------------------------------------------------------------------------
### Aula 03 ###

##GraphQL

#Schema: Contrato (Define os campos que podem ser retornados)
  - Exclamações definem que os campos não pode nulos "!" nos schemas
#Query: Query (Serve para lê as informações do contrato)
#Mutation: Utilizando para fazer a manipulação dos dados 

  

#Scalar Types:
  - Int: 32-bit integer
  - Float
  - String: UTF-8
  - Boolean: true or false
  - ID (serialized as a String)

## Tipo de API's:
  REST,RPC, GraphQL

## Absinthe
  https://github.com/absinthe-graphql/absinthe

#Baixando dependências 
  |> $ mix deps.get

#Formatar o projeto todo com o comando abaixo
  |> $ mix format

--
Aula: 03

00:32:02












